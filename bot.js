const Discord = require('discord.js');
const client = new Discord.Client();
const moment = require('moment');
const ms = require('ms')

client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
});

var guilds = {};
client.on('message',async message => {
 var prefix2 = '$';//ÿßŸÑÿ®ÿ±ŸÅŸÉÿ≥
  if(message.content.startsWith(prefix2 + "ÿ™ŸÇÿØŸäŸÖ")) {
 
if(!message.channel.guild) return message.reply(' ');
 
 
  let submite = message.guild.channels.find(`name`, "ÿ™ŸÇÿØŸäŸÖ");
 
  if(!submite) return message.channel.send("‚ùåŸÑŸÖ ÿßÿ¨ÿØ ÿßŸÑÿ±ŸàŸÖ ÿßŸÑÿÆÿßÿµ ÿ®ÿßŸÑÿ™ŸÇÿØŸäŸÖÿßÿ™");
 
    let filter = m => m.author.id === message.author.id;
 
    let thisMessage;
 
    let thisFalse;
 
    message.channel.send('üìù **| ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖŸÉ ÿßŸÑÿ£ŸÜ... ‚úè **').then(msg => {
 
 
 
    message.channel.awaitMessages(filter, {
 
      max: 1,
 
      time: 90000,
 
      errors: ['time']
 
    })
 
    .then(collected => {
 
      collected.first().delete();
 
      thisMessage = collected.first().content;
 
      let boi;
 
      msg.edit('üìú **| ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ ÿßŸÉÿ™ÿ® ÿπŸÖÿ±ŸÉ  ÿßŸÑÿ£ŸÜ... ‚úè **').then(msg => {
 
 
 
          message.channel.awaitMessages(filter, {
 
            max: 1,
 
            time: 90000,
 
            errors: ['time']
 
          })
 
          .then(collected => {
 
            collected.first().delete();
 
            boi = collected.first().content;
 
            let boi2;
 
            msg.edit('ü§µ **| ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ ÿßŸÉÿ™ÿ® ŸÖŸÜ ÿßŸä ÿ®ŸÑÿØ ÿßŸÜÿ™ ÿßŸÑÿ£ŸÜ... ‚úè **').then(msg => {
 
 
 
              message.channel.awaitMessages(filter, {
 
                max: 1,
 
                time: 90000,
 
                errors: ['time']
 
              })
 
              .then(collected => {
 
                collected.first().delete();
 
              boi2 = collected.first().content;
 
      msg.edit('üõ° **| [ ŸáŸÑ ÿßŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ŸÇÿØŸäŸÖŸÉÿü | [ ŸÜÿπŸÖ ] ÿßŸà [ ŸÑÿß**');
 
 message.channel.awaitMessages(response => response.content === 'ŸÜÿπŸÖ' || 'ŸÑÿß' && filter,{
 
        max: 1,
 
        time: 90000,
 
        errors: ['time']
 
      })
 
      .then(collected => {
 
        if(collected.first().content === 'ŸÑÿß') {
 
          msg.delete();
 
          message.delete();
 
          thisFalse = false;
 
        }
 
        if(collected.first().content === 'ŸÜÿπŸÖ') {
 
          if(thisFalse === false) return;
 
          msg.edit('üïä **| Done ‚úÖ, ÿ™ŸÖ ÿ®ŸÜÿ¨ÿßÿ≠ ŸÜÿ¥ÿ± ÿ™ŸÇÿØŸäŸÖ ŸÅŸä ÿ±ŸàŸÖ ÿßŸÑÿ™ŸÇÿØŸäŸÖÿßÿ™**');
 
          collected.first().delete();
 
          submite.send(`@everyone | @here
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
**[ ${message.guild.name}:arrow_down: ] Submite‚¨á**
 
[**ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÇÿØŸÖ**]:
${thisMessage}
 
[**ÿπŸÖÿ±Ÿá**]:
${boi}
 
[**ŸÖŸÜ ÿ®ŸÑÿØ**]:
${boi2}
 
[**ÿ™ŸÖ ÿßŸÑÿ™ŸÇÿØŸäŸÖ ÿ®Ÿàÿßÿ≥ÿ∑ÿ©**]:
${message.author}
 
[**ÿßŸäÿØŸä ÿßŸÑŸÖŸÇÿØŸÖ**]:
${message.author.id}`);
 
        }
 
      }
 
  );
 
});
 
    });
 
  }
 
    );
 
  });
 
}
 
);
 
    })}});
	
	
	
	
var prefix2 = '$';
	const setc = {}
const setrole = {}
client.on("message", async message => {
	var prefix = "$";
         const nos = new Discord.RichEmbed()
     .setColor("22BF41");
    if(message.content.toLowerCase().startsWith(prefix + `setcategory`)){
    if(!setc[message.guild.id]) setc[message.guild.id] = {
    category: "Tickets"
}
        const category = setc[message.guild.id].category
        let newcategory = message.content.split(' ').slice(1).join(' ');
        let thiscategory = message.guild.channels.find('name', newcategory);
                let fltrc = message.guild.channels.filter(m => m.name === newcategory).type !== 'category';
 if(!setrole[message.guild.id]) setrole[message.guild.id] = {
    role: "Support Team"
}
    const role = setrole[message.guild.id].role
    const srole = setrole[message.guild.id].role
    let thisrole = message.member.roles.find("name", srole);
     const d11x1xx = new Discord.RichEmbed()
     .setDescription(`:x: You do not have permission for that command! If you believe this is a mistake please add the role called \`\`${srole}\`\` to yourself.`)  
     .setColor("22BF41");
    if(!thisrole) return message.channel.send(d11x1xx);
     const NOTX1 = new Discord.RichEmbed()
     .setDescription(`:x: Usage: \`\`${prefix}setcategory <name>\`\``)  
     .setColor("22BF41");
    if(!newcategory) return message.channel.send(NOTX1);
          const CANT = new Discord.RichEmbed()
     .setDescription(`:x: I can't find this category \`\`${newcategory}\`\``)  
     .setColor("22BF41");
        if(!thiscategory) return message.channel.send(CANT);
    const filtr = new Discord.RichEmbed()
     .setDescription(`:x: This not a category \`\`${newcategory}\`\``)  
     .setColor("22BF41");
        if(fltrc) return message.channel.send(filtr);
      setc[message.guild.id].category = newcategory
          const D1 = new Discord.RichEmbed()
     .setDescription(`:white_check_mark: The tickets category has been set to \`\`${newcategory}\`\``)  
     .setColor("22BF41");
    message.channel.send(D1);
       
    }
});
 
 
client.on("message", async message => {
	var prefix = "$";
         const nos = new Discord.RichEmbed()
     .setColor("22BF41");
  
    if(message.content.toLowerCase().startsWith(prefix + `setrole`)){
    if(!setrole[message.guild.id]) setrole[message.guild.id] = {
    role: "Support Team"
}
        const role = setrole[message.guild.id].role
        let newrole = message.content.split(' ').slice(1).join(' ');
        let thisrole = message.guild.roles.find('name', newrole);
        let permission = message.guild.member(message.author).hasPermissions('ADMINISTRATOR');
         const d11x1x42x = new Discord.RichEmbed()
     .setDescription(`:x: You do not have permission for that command! If you believe this is a mistake please add a high role has \`\`ADMINISTRATOR\`\` permission to yourself.`)  
     .setColor("22BF41");
     if(!permission) return message.channel.send(d11x1x42x);
     const NOTX1 = new Discord.RichEmbed()
     .setDescription(`:x: Usage: \`\`${prefix}setrole <name>\`\``)  
     .setColor("22BF41");
    if(!newrole) return message.channel.send(NOTX1);
          const CANT = new Discord.RichEmbed()
     .setDescription(`:x: I can't find this role \`\`${newrole}\`\``)  
     .setColor("22BF41");
        if(!thisrole) return message.channel.send(CANT);
      setrole[message.guild.id].role = newrole 
          const D1 = new Discord.RichEmbed()
     .setDescription(`:white_check_mark: The tickets role has been set to \`\`${newrole}\`\``)  
     .setColor("22BF41");
    message.channel.send(D1);
       
    }
});
 
client.on("message", async message => {
	var prefix = "$";
     const nos = new Discord.RichEmbed()
     .setColor("22BF41");
if(message.content.toLowerCase().startsWith(prefix + `new`)) {
  if(!setc[message.guild.id]) setc[message.guild.id] = {
    category: "Tickets"
}
    const category = setc[message.guild.id].category
    const scategory = setc[message.guild.id].category
   let thiscategory = message.guild.channels.find('name', scategory);
 if(!setrole[message.guild.id]) setrole[message.guild.id] = {
    role: "Support Team"
}
    const role = setrole[message.guild.id].role
    const srole = setrole[message.guild.id].role
   let thisrole = message.guild.roles.find('name', srole);
   let subject = message.content.split(' ').slice(1).join(' ');
   let ticketnumber = 0000;
    if(!subject[0]){
            ticketnumber++;
                 const rerole = new Discord.RichEmbed()
     .setDescription(`:x: Please first make a role called exactly \`\`${srole}\`\``)  
     .setColor("22BF41");          
        if (!thisrole) return message.channel.send(rerole);
              const already = new Discord.RichEmbed()
     .setDescription(":x: You can only have \`\`1\`\` ticket in this server! you already have \`\`1\`\`")  
     .setColor("22BF41");
        if (message.guild.channels.exists("name", "ticket-" + ticketnumber)) return message.channel.send(already);
    if (message.guild.channels.exists("name", "ticket-")) return message.channel.send(already);
    if (message.guild.channels.exists("name", "ticket")) return message.channel.send(already);
    if (message.channel.name.startsWith("ticket-")) return message.channel.send(already);
    if (message.channel.name.startsWith("ticket-" + ticketnumber)) return message.channel.send(already);
        message.guild.createChannel(`ticket-${ticketnumber}`, "text").then(ticketx => {
        ticketx.setParent(thiscategory);
            let role = message.guild.roles.find("name", srole);
            let role2 = message.guild.roles.find("name", "@everyone");
            ticketx.overwritePermissions(role, {
                SEND_MESSAGES: true,
                READ_MESSAGES: true
            });  
            ticketx.overwritePermissions(role2, {
                SEND_MESSAGES: false,
                READ_MESSAGES: false
            });
            ticketx.overwritePermissions(message.author, {
                SEND_MESSAGES: true,
                READ_MESSAGES: true
 
            });
   
       
        const d1 = new Discord.RichEmbed()
     .setDescription(`:white_check_mark: Your ticket has been created <#${ticketx.id}>`)  
     .setColor("22BF41")
            message.channel.send(d1);
            const nonedear = new Discord.RichEmbed()
     .setDescription(`Dear ${message.author}, \n\nThank you for reaching out to our support team!\n\nWe will get back to you as soon as possible\n\n`)
     .addField('Subject' , `No subject has been given`)
     .setColor("22BF41")
     .setFooter(`Nice-Ti v2 || By Sw3rD#0010` , client.user.avatarURL)
     .setTimestamp();
            ticketx.send({embed: nonedear });
        }).catch(console.error);
 
    }
   
 if(subject[0]){
            ticketnumber++;
 const rerole = new Discord.RichEmbed()
     .setDescription(`:x: Please first make a role called exactly \`\`${srole}\`\``)  
     .setColor("22BF41");          
        if (!thisrole) return message.channel.send(rerole);
              const already = new Discord.RichEmbed()
     .setDescription(":x: You can only have \`\`1\`\` ticket in this server! you already have \`\`1\`\`")  
     .setColor("22BF41");
        if (message.guild.channels.exists("name", "ticket-" + ticketnumber)) return message.channel.send(already);
    if (message.guild.channels.exists("name", "ticket-")) return message.channel.send(already);
    if (message.guild.channels.exists("name", "ticket")) return message.channel.send(already);
    if (message.channel.name.startsWith("ticket-")) return message.channel.send(already);
    if (message.channel.name.startsWith("ticket-" + ticketnumber)) return message.channel.send(already);
        message.guild.createChannel(`ticket-${ticketnumber}`, "text").then(ticketx => {
           ticketx.setParent(thiscategory);
            let role = message.guild.roles.find("name", srole);
            let role2 = message.guild.roles.find("name", "@everyone");
            ticketx.overwritePermissions(role, {
                SEND_MESSAGES: true,
                READ_MESSAGES: true
            });  
            ticketx.overwritePermissions(role2, {
                SEND_MESSAGES: false,
                READ_MESSAGES: false
            });
            ticketx.overwritePermissions(message.author, {
                SEND_MESSAGES: true,
                READ_MESSAGES: true
 
            });
       
        const d1 = new Discord.RichEmbed()
     .setDescription(`:white_check_mark: Your ticket has been created <#${ticketx.id}>`)  
     .setColor("22BF41")
            message.channel.send(d1);
            const nonedear = new Discord.RichEmbed()
     .setDescription(`Dear ${message.author}, \n\nThank you for reaching out to our support team!\n\nWe will get back to you as soon as possible\n\n`)
     .addField('Subject' , subject)
     .setColor("22BF41")
     .setFooter(`Nice-Ti v2 || By Sw3rD#0010` , client.user.avatarURL)
     .setTimestamp();
            ticketx.send({embed: nonedear });
        }).catch(console.error);
 
      }  
}
 
 var prefix = "$";
if(message.content.toLowerCase().startsWith(prefix + `close`)) {   
    let team = message.member.roles.find("name", "Support Team");
     const d11x1xx = new Discord.RichEmbed()
     .setDescription(":x: You do not have permission for that command! If you believe this is a mistake please add the role called \`\`‚óè √âlite ¬ª Team\`\` to yourself.")  
     .setColor("22BF41");
    if(!team) return message.channel.send(d11x1xx);
         const d11x1xxNOT = new Discord.RichEmbed()
     .setDescription(":x: You only can run this command in a ticket channel!")  
     .setColor("22BF41");
    if (!message.channel.name.startsWith("ticket-")) return message.channel.send(d11x1xxNOT);
     const yes = new Discord.RichEmbed()
     .setDescription(`:x: Are you sure you want close this ticket? The messages will be gone\nsend \`\`${prefix}close\`\` again to close the ticket.\nYour request will be voided in 20 seconds.`)  
     .setColor("22BF41");
 
    message.channel.send(yes)
    .then((m) => {
      message.channel.awaitMessages(response => response.content === '$close', {
        max: 1,
        time: 20000,
        errors: ['time'],
      })
      .then((collected) => {
          message.channel.delete();
        })
       .catch(() => {
          const yesw = new Discord.RichEmbed()
     .setDescription(`:x: Ticket close timed out, the ticket was not closed.`)  
     .setColor("22BF41");
          m.edit(yesw).then(m2 => {
             m2.delete();
          }, 7000);
        });
    });
  }
 
});
 
//ŸÅŸäŸá setcategory
//setrole
//new
//close
//ŸàŸÇÿ™ ÿ®ÿ™ÿµŸÜÿπ ÿ™ŸäŸÉÿ™ ÿ®ÿ™ŸÉŸàŸÜ ŸÖÿ´ŸÑ ÿ™ŸäŸÉŸäÿ™Ÿä ÿ®ŸÉŸàŸÜ ŸÑÿπÿß ÿπÿØÿßÿØ
// ŸÖÿ´ŸÑ 1, 2 Ÿà ŸÉÿ∞ÿß
	
client.on("guildMemberAdd", member => {
    member.createDM().then(function (channel) {
    return channel.send(` WelCome To Server.${member}:crown:  ÿßŸÜÿ™ ÿßŸÑÿπÿ∂Ÿà ÿ±ŸÇŸÖ ${member.guild.memberCount} `) 
  }).catch(console.error)
  });	
  
  
  client.on('guildMemberAdd', member => {
  
  const channel = member.guild.channels.find(ch => ch.name === 'welcome');
 
  if (!channel) return;

  channel.send(`Welcome to the server, ${member}`);
});



var prefix2 = '$';
client.on('message',async message => {
  if(message.channel.type === 'dm') return;
  if(message.author.bot) return;
  var prefix = "$";
  let args = message.content.split(' ');
  if(args[0] === `${prefix}bc`) {
  if(!message.member.hasPermission("MANAGE_GUILD")) return message.channel.send('- **ÿ£ŸÜÿ™ ŸÑÿß ÿ™ŸÖŸÑŸÉ ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿßÿ™ ÿßŸÑŸÑÿßÿ≤ŸÖÿ© ŸÑÿ£ÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ±**');
  if(!args[1]) return message.channel.send('- **Ÿäÿ¨ÿ® ÿπŸÑŸäŸÉ ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ®ÿπÿØ ÿßŸÑÿ£ŸÖÿ±**');

  let msgCount = 0;
  let errorCount = 0;
  let successCount = 0;
    let status;
    if(msgCount === message.guild.memberCount) {
        status = 'Sent';
    } else if(msgCount !== message.guild.memberCount) {
        status = 'Sending';
    }
  message.channel.send(`**- [ üîñ :: ${msgCount} ] „ÉªÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ©**\n**- [ üì• :: ${successCount} ] „ÉªÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ≥ÿ™ŸÑŸÖÿ©**\n**- [ üì§ :: ${errorCount} ]„ÉªÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ∫Ÿäÿ± ŸÖÿ≥ÿ™ŸÑŸÖÿ©\n- [ ‚ñ´ :: ${status} ]„Éªÿ≠ÿßŸÑÿ© ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ©**`).then(msg => {
    message.guild.members.forEach(g => {
      g.send(args.slice(1).join(' ')).then(() => {
        successCount++;
        msgCount++;
                if(!msg) return;
        msg.edit(`**- [ üîñ :: ${msgCount} ] „ÉªÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ©**\n**- [ üì• :: ${successCount} ] „ÉªÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ≥ÿ™ŸÑŸÖÿ©**\n**- [ üì§ :: ${errorCount} ]„ÉªÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ∫Ÿäÿ± ŸÖÿ≥ÿ™ŸÑŸÖÿ©\n- [ ‚ñ´ :: ${status} ]„Éªÿ≠ÿßŸÑÿ© ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ±ÿ≥ŸÑ**`);
      }).catch(e => {
        errorCount++;
        msgCount++;
                if(!msg) return;
        msg.edit(`**- [ üîñ :: ${msgCount} ] „ÉªÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ©**\n**- [ üì• :: ${successCount} ] „ÉªÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ≥ÿ™ŸÑŸÖÿ©**\n**- [ üì§ :: ${errorCount} ]„ÉªÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ∫Ÿäÿ± ŸÖÿ≥ÿ™ŸÑŸÖÿ©\n- [ ‚ñ´ :: ${status} ]„Éªÿ≠ÿßŸÑÿ© ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ±ÿ≥ŸÑ**`);
      });
    });
  });
}
});


client.on("message", async message => {
            if(!message.channel.guild) return;
            var prefix = "$";
        if(message.content.startsWith(prefix + 'invites')) {
        var nul = 0
        var guild = message.guild
        await guild.fetchInvites()
            .then(invites => {
             invites.forEach(invite => {
                if (invite.inviter === message.author) {
                     nul+=invite.uses
                    }
                });
            });
          if (nul > 0) {
              console.log(`\n${message.author.tag} has ${nul} invites in ${guild.name}\n`)
              var embed = new Discord.RichEmbed()
                  .setColor("#000000")
                    .addField(`${message.author.username}`, `ŸÑŸÇÿØ ŸÇŸÖÿ™ ÿ®ÿØÿπŸàÿ© **${nul}** ÿ¥ÿÆÿµ`)
                          message.channel.send({ embed: embed });
                      return;
                    } else {
                       var embed = new Discord.RichEmbed()
                        .setColor("#000000")
                        .addField(`${message.author.username}`, `ŸÑŸÖ ÿ™ŸÇŸÖ ÿ®ÿØÿπŸàÿ© ÿ£Ÿä ÿ¥ÿÆÿµ ŸÑŸáÿ∞ÿ© ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±`)
 
                       message.channel.send({ embed: embed });
                        return;
                    }
        }
        if(message.content.startsWith(prefix + 'invite-codes')) {
let guild = message.guild
var codes = [""]
message.channel.send(":postbox: **ŸÑŸÇÿØ ŸÇŸÖÿ™ ÿ®ÿ£ÿ±ÿ≥ÿßŸÑ ÿ¨ŸÖŸäÿπ ÿ±Ÿàÿßÿ®ÿ∑ ÿßŸÑÿØÿπŸàÿßÿ™ ÿßŸÑÿ™Ÿä ŸÇŸÖÿ™ ÿ®ÿ£ŸÜÿ¥ÿßÿ¶Ÿáÿß ŸÅŸä ÿßŸÑÿÆÿßÿµ**")
guild.fetchInvites()
.then(invites => {
invites.forEach(invite => {
if (invite.inviter === message.author) {
codes.push(`discord.gg/${invite.code}`)
}
})
}).then(m => {
if (codes.length < 0) {
    var embed = new Discord.RichEmbed()
.setColor("#000000")
.addField(`Your invite codes in ${message.guild.name}`, `You currently don't have any active invites! Please create an invite and start inviting, then you will be able to see your codes here!`)
message.author.send({ embed: embed });
return;
} else {
    var embed = new Discord.RichEmbed()
.setColor("#000000")
.addField(`Your invite codes in ${message.guild.name}`, `Invite Codes:\n${codes.join("\n")}`)
message.author.send({ embed: embed });
return;
}
})
}
 
});


client.on('guildMemberAdd', member=> {
    member.addRole(member.guild.roles.find("name","Ghosts"));
    });
	
	client.on('message' , async (message) => {
var prefix = "$"
    if(message.content.startsWith(prefix + "topinv")) {
if(message.author.bot) return;
if(!message.channel.guild) return message.reply(' Error : \` Guild Command \`');
  var invites = await message.guild.fetchInvites();
    invites = invites.array();
    arraySort(invites, 'uses', { reverse: true });
    let possibleInvites = ['User Invited |  Uses '];
    invites.forEach(i => {
        if (i.uses === 0) { 
            return;
        }
      possibleInvites.push(['\n\ ' +'<@'+ i.inviter.id +'>' + '  :  ' +   i.uses]);
     //ŸÖÿπŸÑŸàŸÖŸá ÿ®ÿ≥Ÿäÿ∑Ÿá ŸäŸÖÿØŸäŸÉ ÿ™ŸÉÿ±ÿ± ÿßŸÑÿπŸÖŸÑŸäŸáŸá ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ŸÖÿ±Ÿá
    })
    const embed = new Discord.RichEmbed()
 .setColor('RANDOM')
    .addField("Top Invites." ,`${(possibleInvites)}`)

    message.channel.send(embed)
    }
});


client.on('guildMemberAdd', member => {

    const channel = member.guild.channels.find('name', '„Éªwelcome');
  
    const millis = new Date().getTime() - member.user.createdAt.getTime();
    const now = new Date();
    const createdAt = millis / 1000 / 60 / 60 / 24;




  
    const embed = new Discord.RichEmbed()
    
    .setColor("black")
    .setDescription(`**ÿ™ÿßÿ±ŸäÿÆ ÿØÿÆŸàŸÑŸÉ ŸÑŸÑÿØÿ≥ŸÉŸàÿ±ÿØ ŸÖŸÜÿ∞ ${createdAt.toFixed(0)} ŸäŸàŸÖ**`)
    .setAuthor(member.user.tag, member.user.avatarURL);
    channel.sendEmbed(embed);

  
});


client.on('message',async message => {
    const moment = require('moment');
const ms = require('ms')
    var prefix = '$'
  var time = moment().format('Do MMMM YYYY , hh:mm');
  var room;
  var title;
  var duration;
  var currentTime = new Date(),
hours = currentTime.getHours() + 3 ,
minutes = currentTime.getMinutes(),
done = currentTime.getMinutes() + duration,
seconds = currentTime.getSeconds();
if (minutes < 10) {
minutes = "0" + minutes;
}
var suffix = "AM";
if (hours >= 12) {
suffix = "PM";
hours = hours - 12;
}
if (hours == 0) {
hours = 12;
}

  var filter = m => m.author.id === message.author.id;
  if(message.content.startsWith(prefix + "gstart")) { // ÿßŸÑÿßŸÖÿ±

    if(!message.guild.member(message.author).hasPermission('MANAGE_GUILD')) return message.channel.send(':heavy_multiplication_x:| **Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ŸÑÿØŸäŸÉ ÿÆÿßÿµŸäÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ ÿπŸÑŸâ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±**');
    message.channel.send(`:eight_pointed_black_star:| **Send Name channel For the Giveaway**`).then(msg => {
      message.channel.awaitMessages(filter, {
        max: 1,
        time: 20000,
        errors: ['time']
      }).then(collected => {
        let room = message.guild.channels.find('name' , collected.first().content);
        if(!room) return message.channel.send(':heavy_multiplication_x:| **i Found It :(**');
        room = collected.first().content;
        collected.first().delete();
        msg.edit(':eight_pointed_black_star:| **Time For The Giveaway**').then(msg => {
          message.channel.awaitMessages(filter, {
            max: 1,
            time: 20000,
            errors: ['time']
          }).then(collected => {
            if(!collected.first().content.match(/[1-60][s,m,h,d,w]/g)) return message.channel.send('**The Bot Not Support This Time**');
            duration = collected.first().content
            collected.first().delete();
            msg.edit(':eight_pointed_black_star:| **Now send The Present **').then(msg => {
              message.channel.awaitMessages(filter, {
                max: 1,
                time: 20000,
                errors: ['time']
              }).then(collected => {
                title = collected.first().content;
                collected.first().delete();
                msg.delete();
                message.delete();
                try {
                  let giveEmbed = new Discord.RichEmbed()
                  .setDescription(`**${title}** \nReact With üéâ To Enter! \nTime remaining : ${duration} \n **Created at :** ${hours}:${minutes}:${seconds} ${suffix}`)
                  .setFooter(message.author.username, message.author.avatarURL);
                  message.guild.channels.find("name" , room).send(' :heavy_check_mark: **Giveaway Created** :heavy_check_mark:' , {embed: giveEmbed}).then(m => {
                     let re = m.react('üéâ');
                     setTimeout(() => {
                       let users = m.reactions.get("üéâ").users
                       let list = users.array().filter(u => u.id !== m.author.id !== client.user.id);
                       let gFilter = list[Math.floor(Math.random() * list.length) + 0]
                       let endEmbed = new Discord.RichEmbed()
                       .setAuthor(message.author.username, message.author.avatarURL)
                       .setTitle(title)
                       .addField('Giveaway Ended !üéâ',`Winners : ${gFilter} \nEnded at :`)
                       .setTimestamp()
					 m.edit('** üéâ GIVEAWAY ENDED üéâ**' , {embed: endEmbed});
					message.guild.channels.find("name" , room).send(`**Congratulations ${gFilter}! You won The \`${title}\`**` , {embed: {}})
                }, ms(duration));
            });
                } catch(e) {
                message.channel.send(`:heavy_multiplication_x:| **i Don't Have Prem**`);
                  console.log(e);
                }
              });
            });
          });
        });
      });
    });
  }
});


client.on('message', function(msg) {
	var prefix = "$"
if(msg.content.startsWith (prefix  + 'serverinfo')) {
 let embed = new Discord.RichEmbed()
 .setColor('RANDOM')
 .setThumbnail(msg.guild.iconURL)
 .setTitle(`Showing Details Of  **${msg.guild.name}*`)
 .addField('üåê** ŸÜŸàÿπ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±**',`[** __${msg.guild.region}__ **]`,true)
 .addField('üèÖ** __ÿßŸÑÿ±ÿ™ÿ®__**',`[** __${msg.guild.roles.size}__ **]`,true)
 .addField('üî¥**__ ÿπÿØÿØ ÿßŸÑÿßÿπÿ∂ÿßÿ°__**',`[** __${msg.guild.memberCount}__ **]`,true)
 .addField('üîµ**__ ÿπÿØÿØ ÿßŸÑÿßÿπÿ∂ÿßÿ° ÿßŸÑÿßŸàŸÜŸÑÿßŸäŸÜ__**',`[** __${msg.guild.members.filter(m=>m.presence.status == 'online').size}__ **]`,true)
 .addField('üìù**__ ÿßŸÑÿ±ŸàŸÖÿßÿ™ ÿßŸÑŸÉÿ™ÿßÿ®Ÿäÿ©__**',`[** __${msg.guild.channels.filter(m => m.type === 'text').size}__** ]`,true)
 .addField('üé§**__ ÿ±ŸàŸÖÿßÿ™ ÿßŸÑÿµŸàÿ™__**',`[** __${msg.guild.channels.filter(m => m.type === 'voice').size}__ **]`,true)
 .addField('üëë**__ ÿßŸÑÿ£ŸàŸÜŸÄÿ±__**',`**${msg.guild.owner}**`,true)
 .addField('üÜî**__ ÿßŸäÿØŸä ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±__**',`**${msg.guild.id}**`,true)
 .addField('üìÖ**__ ÿ™ŸÖ ÿπŸÖŸÑ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± ŸÅŸä__**',msg.guild.createdAt.toLocaleString())
 msg.channel.send({embed:embed});
}
});
 
 
 client.on('message', message => {
    if (message.content.startsWith("$avatar")) {  //// ÿßŸÑÿßŸÖÿ± Ÿà ÿßŸÑÿ®ÿ±ŸÅŸäŸÉÿ≥
        if (message.author.bot) return
        var mentionned = message.mentions.users.first();
    var omar;
      if(mentionned){
          var omar = mentionned;
      } else {
          var omar = message.author;
          
      }
        const embed = new Discord.RichEmbed()
        .setColor("RANDOM")
        .setAuthor('Avatar Link :')
        .setTitle('Click Here')
        .setURL(`${omar.avatarURL}`)
        .setImage(`${omar.avatarURL}`)
        .setFooter(' ',client.user.avatarURL) 
      message.channel.sendEmbed(embed);
    }
});



client.on("message", msg => {
  if(msg.content === '$' + "id") {
      const embed = new Discord.RichEmbed();
  embed.addField("üî±| name :", `${msg.author.username}#${msg.author.discriminator}`, true)
          .setColor("RANDOM")
          .setFooter(msg.author.username , msg.author.avatarURL)
          .setThumbnail(`${msg.author.avatarURL}`)
          .setTimestamp()
          .setURL(`${msg.author.avatarURL}`)
          .addField('üìõ| state :', `${msg.author.presence.status.toUpperCase()}`, true)
          .addField('üé≤| playing :', `${msg.author.presence.game === null ? "No Game" : msg.author.presence.game.name}`, true)
   .addField(':military_medal:  rank', `**[ ${msg.member.roles.filter(r => r.name).size} ]**`, true)
          .addField('üìÖ| Join the Discord in :', `${msg.createdAt}`,true);
      msg.channel.send({embed: embed})
  }
});



client.on('message', message => {
    if (message.content.startsWith("$link")) {
 
  message.channel.createInvite({
        thing: true,
        maxUses: 100,
        maxAge: 86400
    }).then(invite =>
      message.author.sendMessage(invite.url)
    )
    const embed = new Discord.RichEmbed()
        .setColor("RANDOM")
        .setDescription("| :white_check_mark:  | :heart:  We have been sent to your  ")
      message.channel.sendEmbed(embed).then(message => {message.delete(10000)})
              const Embed11 = new Discord.RichEmbed()
        .setColor("RANDOM")
                .setAuthor(message.guild.name, message.guild.iconURL)
        .setDescription(`
**
---------------------
-[${message.guild.name}]  This is a server link
---------------------
-This link is valid for only 100 users
---------------------
-This link is only valid for 24 hours
---------------------
**`)
      message.author.sendEmbed(Embed11)
    }
});


client.on('ready', () => {
client.user.setGame(`$help'GhostsBOT`);
});


client.on("message", message => {
var prefix = "$" // ÿßŸÑÿ®ÿ±ŸäŸÅŸÉÿ≥
    var args = message.content.substring(prefix.length).split(" ");
    if (message.content.startsWith(prefix + "clear")) { // ÿßŸÑÿßŸÖÿ±
        if(!message.channel.guild) return message.reply('**‚ùå Sorry but this is for servers only **');         
if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply('**‚ö†  You do not have permission to delete chat**');
var msg;
msg = parseInt();

message.channel.fetchMessages({limit: msg}).then(messages => message.channel.bulkDelete(messages)).catch(console.error);
message.channel.sendMessage("", {embed: {
title: "``ÿ™ŸÄŸÄŸÖ ŸÖÿ≥ÿ≠ ÿßŸÑÿ¥ÿßÿ™ ``",
color: 0x06DF00,
footer: {
  
}
}}).then(msg => {msg.delete(3000)});
                  }


});

var prefix = "$"

client.on("message", message => {
    if (message.content === (prefix + "help")) {
     const embed = new Discord.RichEmbed() 
         .setColor("#580e6b")
         .setThumbnail(message.author.avatarURL)
         .setDescription(`
   
   **
   

   **
   
 	         ------------------------------
		 ÿßŸÑÿßŸàÿßŸÖÿ± ÿßŸÑÿπÿßÿØŸäŸá
         $avatar:
         $id :
         $serverinfo :
		 $link:
		 $ÿ™ŸÇÿØŸäŸÖ:
		 $new
         ------------------------------
		 ÿßŸàÿßŸÖÿ± ÿßŸÑÿßÿØŸÖŸÜ
         $clear :
		 $bc:
		 $gstart:

   **

   `)
   message.author.sendEmbed(embed)
   
   }
   });  
client.on('message', message => {
     if (message.content === (prefix + "help")) {
     let embed = new Discord.RichEmbed()
  .setAuthor(message.author.username)
  .setColor("#8650a7")
  .addField("Done" , " ÿ™ŸÄŸÄŸÄŸÄŸÖ ÿßÿ±ÿ≥ŸÄŸÄÿßŸÑŸÉ ŸÅŸä ÿßŸÑÿÆŸÄŸÄÿßÿµ")
  message.channel.sendEmbed(embed);
    }
});


client.login(process.env.BOT_TOKEN);
